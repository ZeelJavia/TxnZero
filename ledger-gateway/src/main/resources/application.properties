server.port=8080
spring.application.name=ledger-gateway

# ==========================================
# ? DATABASE CONFIGURATION (Read/Write Split)
# ==========================================

# ? WRITER (Primary Instance) - For @Transactional
spring.datasource.writer.jdbc-url=${RDS_DB_URL}
spring.datasource.writer.username=${RDS_DB_UNAME}
spring.datasource.writer.password=${RDS_DB_PASS}
spring.datasource.writer.driver-class-name=org.postgresql.Driver
# Connection Pool Settings for Writer
spring.datasource.writer.hikari.maximum-pool-size=10
spring.datasource.writer.hikari.minimum-idle=5
spring.datasource.writer.hikari.pool-name=HikariPool-Writer

# ? READER (Read Replica) - For @Transactional(readOnly=true)
# You must add RDS_READ_DB_URL to your environment variables!
spring.datasource.reader.jdbc-url=${RDS_READ_DB_URL}

# Monitoring
management.endpoints.web.exposure.include=health,info,prometheus
management.endpoint.health.show-details=always
management.metrics.tags.application=${spring.application.name}
spring.datasource.reader.username=${RDS_DB_UNAME}
spring.datasource.reader.password=${RDS_DB_PASS}
spring.datasource.reader.driver-class-name=org.postgresql.Driver
# Replicas can handle more connections since they only read
spring.datasource.reader.hikari.maximum-pool-size=20
spring.datasource.reader.hikari.minimum-idle=5
spring.datasource.reader.hikari.pool-name=HikariPool-Reader

# ==========================================
# JPA / Hibernate Config
# ==========================================
# These settings apply to the EntityManager (which uses the RoutingDataSource)
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true

# Disable standard DataSource auto-configuration to let our Java Config take over
#spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

# ==========================================
# LOGGING
# ==========================================
logging.level.org.example=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# ==========================================
# INTEGRATIONS & SECURITY
# ==========================================
# Service Links
app.urls.switch=${SWITCH_SERVICE_URL}

# SNS
cloud.aws.credentials.access-key=${AWS_CLOUD_CREDENTIALS_ACCESS_KEY}
cloud.aws.credentials.secret-key=${AWS_CLOUD_CREDENTIALS_SECRET_KEY}
cloud.aws.region.static=${AWS_CLOUD_REGION}

# JWT Secret
jwt.secret-key=${JWT_TOKEN}

# Frontend URL
frontend_url=${FRONTEND_URL:http://localhost:5173}

#sqs
aws.sqs.queue-url=${AWS_SQS_QUEUE}

# ==========================================
# KAFKA CONFIGURATION (Consumer)
# ==========================================
# Set kafka.enabled=true to enable Kafka notifications (requires running Kafka)
kafka.enabled=${KAFKA_ENABLED:true}

spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}

# CONSUMER
spring.kafka.consumer.group-id=gateway-notification-group
spring.kafka.consumer.auto-offset-reset=latest
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=org.example.dto

# PRODUCER (THIS FIXES THE ERROR)
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
